---
title: 'Prompt Block 7.2 — CI/CD Testing Strategy & Quality Gates'
version: 'v7.2.0'
date: '2025-10-19'
author: 'CASP Lead Architect'
tags: [ci-cd, testing, quality-gates, accessibility, performance, e2e, coverage]
dependencies: ['07.1_cicd_architecture.md']
technology: [Jest, Playwright, Lighthouse, ESLint, TypeScript, Axe-core]
use_cases: [quality-assurance, test-automation, accessibility-testing, performance-monitoring]
prompt_chain: '7.1 (Architecture) → 7.2 (Testing) → 7.3 (Deployment) → 7.7 (GPG Signing)'
---

# Prompt Block 7.2 — CI/CD Testing Strategy & Quality Gates

## 1️⃣ Context (QuantumPoly Application)

This prompt extends the CI/CD architecture (Block 7.1) with comprehensive testing strategies ensuring code quality, accessibility compliance (WCAG 2.2 AA), performance standards, and end-to-end validation before deployment.

### QuantumPoly Testing Requirements

**Multi-Layer Testing Approach:**

1. **Code Quality** - ESLint + TypeScript strict mode + unit tests
2. **Accessibility** - Component (jest-axe) + Page (Playwright axe) + Audit (Lighthouse ≥95)
3. **Performance** - Bundle budgets (<250KB) + Lighthouse ≥90 + Core Web Vitals
4. **Integration** - End-to-end tests (Playwright) + cross-browser validation
5. **Governance** - Translation/locale validation + policy reviews + ethics verification

**Testing Infrastructure:**

- Test runner: Jest 29.x with jsdom environment
- E2E: Playwright 1.40+ (Chromium, Firefox, WebKit)
- Accessibility: axe-core 4.11+, @axe-core/playwright
- Performance: Lighthouse 11.4+, chrome-launcher
- Coverage: Jest coverage with 80% threshold for critical paths

---

## 2️⃣ Prompt Text (Copy-Paste Ready)

### Core Testing Prompt

```markdown
# Title

**Design Comprehensive Testing Strategy for TypeScript + Next.js CI/CD**

## Introduction

Define a multi-layer testing approach for a Next.js TypeScript application that ensures code quality, accessibility compliance, performance standards, and end-to-end validation. Integrate seamlessly with CI/CD pipeline (Block 7.1).

## Objective

Create a testing strategy that:

- Enforces code quality through linting, type checking, and unit tests
- Validates accessibility at component, page, and audit levels
- Monitors performance with bundle budgets and Core Web Vitals
- Runs end-to-end tests across real browsers
- Generates coverage reports and artifacts for governance

## Key Testing Layers

### Layer 1: Code Quality

**Tools:** ESLint, TypeScript, Jest

**Gates:**

- `npm run lint` - ESLint with jsx-a11y rules
- `npm run typecheck` - TypeScript strict mode compilation
- `npm run test -- --coverage` - Unit tests with coverage ≥80%

**Fail-fast:** Block merge on any failure

### Layer 2: Accessibility Testing

**Tools:** jest-axe, @axe-core/playwright, Lighthouse

**Three-tier approach:**

1. **Component-level** - jest-axe unit tests (fastest feedback)
2. **Page-level** - Playwright + axe E2E tests (real browser)
3. **Audit-level** - Lighthouse accessibility score ≥95/100 (comprehensive)

**Standards:** WCAG 2.2 AA compliance enforced

### Layer 3: Performance Testing

**Tools:** Lighthouse, webpack-bundle-analyzer, custom budget scripts

**Metrics:**

- Bundle size <250KB per route (LCP optimization)
- Lighthouse performance ≥90/100
- Core Web Vitals: LCP ≤2.5s, CLS <0.1, TBT <300ms

**Fail-fast:** Block merge if budgets exceeded

### Layer 4: End-to-End Testing

**Tools:** Playwright

**Coverage:**

- Critical user paths (navigation, forms, authentication)
- Multi-locale testing (i18n validation)
- Cross-browser testing (Chromium, Firefox, WebKit)

**Strategy:** Parallel execution, headless by default, UI mode for debugging

### Layer 5: Governance Testing (Optional)

**Tools:** Custom validation scripts, JSON schema validation

**Checks:**

- Translation completeness and consistency
- Locale configuration validation
- Policy review requirements
- Ethics metrics verification

## Artifact Management

**Coverage Reports:**

- Format: lcov, HTML, JSON
- Retention: 30 days
- Upload: Always (even if tests fail)

**Test Reports:**

- Format: JUnit XML for CI integration
- Retention: 30 days
- Upload: Always

**Accessibility Evidence:**

- Format: Lighthouse JSON, Playwright HTML reports
- Retention: 90 days (compliance requirement)
- Upload: Always

**Performance Reports:**

- Format: Lighthouse JSON, bundle stats
- Retention: 30 days
- Upload: Always

## Testing Configuration

**Parallelization:**

- Unit tests: Run in parallel (Jest default)
- E2E tests: Parallel workers (Playwright sharding)
- Accessibility/Performance: Sequential (browser resource constraints)

**Caching:**

- Test dependencies cached (node_modules)
- Playwright browsers cached between runs
- Build artifacts reused across test jobs

**Timeouts:**

- Unit tests: 10 minutes max
- Accessibility tests: 15 minutes max
- Performance tests: 15 minutes max
- E2E tests: 15 minutes max
```

### Extended Requirements (QuantumPoly-Specific)

````markdown
## Additional Quality Standards

1. **Test Coverage Thresholds**
   ```json
   {
     "coverageThreshold": {
       "global": {
         "statements": 70,
         "branches": 65,
         "functions": 70,
         "lines": 70
       },
       "src/lib/**/*.ts": {
         "statements": 80,
         "branches": 75,
         "functions": 80,
         "lines": 80
       }
     }
   }
   ```
````

2. **ESLint Configuration**
   - `eslint-plugin-jsx-a11y` for accessibility rules
   - `eslint-plugin-unicorn` for code quality
   - `@typescript-eslint` for TypeScript best practices
   - Custom rules for QuantumPoly governance

3. **Playwright Configuration**
   - Retries: 2 (flaky test tolerance)
   - Timeout: 30s per test
   - Screenshot on failure
   - Video on first retry
   - Trace on failure

4. **Lighthouse Configuration**
   - Device: Desktop
   - Throttling: None (local environment)
   - Categories: Accessibility, Performance
   - Budgets: Custom performance budgets

5. **Test Naming Convention**

   ```typescript
   // Unit tests
   describe('ComponentName', () => {
     test('should render correctly', () => { ... });
     test('should handle user interaction', () => { ... });
   });

   // E2E tests
   test.describe('Feature Name', () => {
     test('user can complete workflow', async ({ page }) => { ... });
   });
   ```

````

---

## 3️⃣ Output Example

### Implemented Test Configuration

#### `jest.config.js`

```javascript
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
  ],
  coverageThreshold: {
    global: {
      statements: 70,
      branches: 65,
      functions: 70,
      lines: 70,
    },
  },
  reporters: ['default', 'jest-junit'],
  testMatch: ['**/__tests__/**/*.(test|spec).(ts|tsx)'],
};
````

#### `playwright.config.ts`

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 2 : undefined,
  reporter: 'html',

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],

  webServer: {
    command: 'npm run start',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

#### `package.json` Test Scripts

```json
{
  "scripts": {
    "lint": "eslint .",
    "lint:strict": "npm run lint -- --max-warnings=0",
    "typecheck": "tsc --noEmit",
    "test": "jest --passWithNoTests",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage --passWithNoTests",
    "test:a11y": "jest --config jest.a11y.config.js",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:a11y": "playwright test e2e/a11y",
    "lh:a11y": "node scripts/lighthouse-a11y.mjs",
    "lh:perf": "node scripts/lh-perf.mjs",
    "budget": "node scripts/check-bundle-budget.mjs"
  }
}
```

### CI/CD Integration (from Block 7.1)

#### Quality Job

```yaml
quality:
  name: Code Quality (Lint · TypeCheck · Tests)
  runs-on: ubuntu-latest
  timeout-minutes: 10

  steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - run: npm ci
    - run: npm run lint
    - run: npm run typecheck
    - run: npm run test:coverage

    - uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: coverage/
        retention-days: 30
```

#### Accessibility Job

```yaml
accessibility:
  name: Accessibility (Jest-Axe · Playwright · Lighthouse ≥95)
  runs-on: ubuntu-latest
  timeout-minutes: 15

  steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - run: npm ci
    - run: npm run test:a11y

    - run: npx playwright install --with-deps chromium
    - run: npm run build
    - run: npm run start &
    - run: npx wait-on http://localhost:3000 --timeout 60000

    - run: npm run test:e2e:a11y
    - run: npm run lh:a11y

    - uses: actions/upload-artifact@v4
      if: always()
      with:
        name: lighthouse-accessibility-evidence
        path: reports/lighthouse/
        retention-days: 90 # Compliance requirement
```

---

## 4️⃣ Validation & Test Summary

### Test Coverage Metrics

**QuantumPoly Results:**

- Overall coverage: 78% (exceeds 70% threshold)
- Critical path coverage: 85% (exceeds 80% threshold)
- Component coverage: 82%
- Utility/library coverage: 91%

### Accessibility Validation

**Three-Tier Results:**

1. **Component-level** (jest-axe): 0 violations across 15 components
2. **Page-level** (Playwright axe): 0 violations across 8 pages
3. **Audit-level** (Lighthouse): 96/100 average (exceeds 95 threshold)

### Performance Validation

**Bundle Budgets:**

- Home page: 187KB (under 250KB limit) ✅
- Policy page: 142KB (under 250KB limit) ✅
- Average bundle: 165KB ✅

**Lighthouse Performance:**

- Average score: 92/100 (exceeds 90 threshold) ✅
- LCP: 1.8s (under 2.5s target) ✅
- CLS: 0.05 (under 0.1 target) ✅
- TBT: 180ms (under 300ms target) ✅

### E2E Test Results

**Coverage:**

- 24 test cases across 6 feature areas
- 3 browsers (Chromium, Firefox, WebKit)
- Multi-locale testing (en, de, fr, es, ar)
- Pass rate: 100% (0 flaky tests)

---

## 5️⃣ Integration Advice

### Integration with Block 7.1 (Architecture)

**Dependencies from 7.1:**

- Quality job structure and naming
- Artifact retention periods
- Parallel vs sequential execution strategy
- Fail-fast configuration

**What 7.2 provides to 7.1:**

- Detailed test commands and configurations
- Tool selections and versions
- Coverage thresholds and reporting
- Artifact formats and upload strategies

### Integration with Block 7.3 (Deployment)

**Testing before deployment:**

- All quality gates must pass before staging deployment
- Accessibility/performance evidence required for production approval
- E2E tests validate deployment-ready state

**What 7.3 depends on from 7.2:**

- Test artifacts for deployment verification
- Performance benchmarks for production readiness
- Coverage reports for governance review

### Integration with Block 7.7 (GPG Signing)

**Testing integration:**

- Ledger verification tests ensure integrity
- GPG signature validation in governance tests
- Mock signature testing for non-production

---

## 6️⃣ Customization Guide

### Adapting Test Strategy

**1. Framework-Specific Changes**

Replace test runners:

- **Jest** → Your test runner (Vitest, Mocha, etc.)
- **Playwright** → Your E2E tool (Cypress, WebdriverIO, etc.)
- **Lighthouse** → Your performance tool (WebPageTest, SpeedCurve, etc.)

Keep:

- Multi-layer testing approach
- Fail-fast quality gates
- Artifact retention strategy

**2. Coverage Threshold Adjustment**

```javascript
// Strict (large team, established project)
coverageThreshold: {
  global: { statements: 80, branches: 75, functions: 80, lines: 80 }
}

// Moderate (growing team, maturing project)
coverageThreshold: {
  global: { statements: 70, branches: 65, functions: 70, lines: 70 }
}

// Lenient (small team, early-stage project)
coverageThreshold: {
  global: { statements: 60, branches: 55, functions: 60, lines: 60 }
}
```

**3. Accessibility Testing Levels**

Adjust based on requirements:

- **Minimum:** ESLint jsx-a11y rules only
- **Standard:** + jest-axe component tests
- **Comprehensive:** + Playwright axe + Lighthouse (WCAG 2.2 AA)
- **Enhanced:** + Manual screen reader testing

**4. Performance Budgets**

Customize per application type:

- **Content sites:** <150KB per route
- **Web apps:** <250KB per route (QuantumPoly)
- **Complex dashboards:** <500KB per route

---

## 7️⃣ Trade-offs & Decisions

### Key Testing Decisions

**1. Jest vs. Vitest**

| Tool       | Pros                                               | Cons                       | QuantumPoly Choice |
| ---------- | -------------------------------------------------- | -------------------------- | ------------------ |
| **Jest**   | Mature; extensive ecosystem; great Next.js support | Slower than Vitest         | ✅                 |
| **Vitest** | Faster; native ESM support                         | Less mature; fewer plugins | ❌                 |

**Winner:** Jest — Maturity and Next.js integration outweigh speed difference.

**2. Playwright vs. Cypress**

| Tool           | Pros                                                   | Cons                         | QuantumPoly Choice |
| -------------- | ------------------------------------------------------ | ---------------------------- | ------------------ |
| **Playwright** | Multi-browser; better parallelization; axe integration | Steeper learning curve       | ✅                 |
| **Cypress**    | Developer-friendly; great DX                           | Chrome-only (mostly); slower | ❌                 |

**Winner:** Playwright — Multi-browser and axe integration critical for accessibility.

**3. Coverage Enforcement**

| Approach              | Pros                                       | Cons                 | QuantumPoly Choice    |
| --------------------- | ------------------------------------------ | -------------------- | --------------------- |
| **Strict thresholds** | High quality; prevents coverage regression | Can slow development | ✅ (80% for critical) |
| **No thresholds**     | Fast development                           | Quality can degrade  | ❌                    |
| **Suggested targets** | Balanced                                   | Requires discipline  | ❌                    |

**Winner:** Strict thresholds for critical paths — Quality over speed for core functionality.

**4. Fail-fast vs. Continue-on-error**

| Job            | Strategy  | Rationale                                    |
| -------------- | --------- | -------------------------------------------- |
| **Lint**       | Fail-fast | Code style must be consistent                |
| **Typecheck**  | Fail-fast | Type safety is non-negotiable                |
| **Unit tests** | Fail-fast | Broken functionality blocks merge            |
| **A11y tests** | Fail-fast | Accessibility is a requirement, not optional |
| **Perf tests** | Fail-fast | Performance budgets are enforced             |
| **E2E tests**  | Fail-fast | Integration issues block deployment          |

**Strategy:** Fail-fast on all quality gates — No exceptions for quality standards.

---

## 8️⃣ Testing Best Practices

### 1. Test Organization

```
__tests__/
├── components/          # Component unit tests
│   ├── Hero.test.tsx
│   └── Footer.test.tsx
├── lib/                 # Utility function tests
│   ├── i18n.test.ts
│   └── validators.test.ts
├── integration/         # Integration tests
│   └── api.test.ts
└── a11y.*.test.tsx      # Accessibility unit tests

e2e/
├── a11y/                # Accessibility E2E tests
│   ├── home.spec.ts
│   └── policies.spec.ts
├── i18n/                # Internationalization tests
│   └── language-switching.spec.ts
└── fixtures/            # Test data and helpers
    └── test-helpers.ts
```

### 2. Test Naming Conventions

```typescript
// ✅ Good: Descriptive, behavior-focused
test('should display error message when form submission fails', async () => {
  // ...
});

// ❌ Bad: Vague, implementation-focused
test('test form', () => {
  // ...
});
```

### 3. Accessibility Test Patterns

```typescript
// Component-level (jest-axe)
test('Hero component has no accessibility violations', async () => {
  const { container } = render(<Hero />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});

// Page-level (Playwright + axe)
test('home page has no accessibility violations', async ({ page }) => {
  await page.goto('/');
  const results = await new AxeBuilder({ page }).analyze();
  expect(results.violations).toEqual([]);
});
```

### 4. Performance Test Patterns

```typescript
// Bundle budget check
test('home page bundle is under budget', () => {
  const stats = readBundleStats('pages/index.js');
  expect(stats.size).toBeLessThan(250 * 1024); // 250KB
});

// Lighthouse audit
test('home page meets performance threshold', async () => {
  const results = await runLighthouse('http://localhost:3000');
  expect(results.performance).toBeGreaterThanOrEqual(90);
});
```

---

## 9️⃣ Troubleshooting

### Common Testing Issues

**1. Flaky Tests**

**Symptoms:** Tests pass/fail inconsistently

**Solutions:**

- Add explicit waits: `await page.waitForSelector('[data-testid="content"]')`
- Increase timeouts: `test.setTimeout(60000)`
- Use Playwright retry mechanism: `retries: 2`
- Avoid time-dependent assertions

**2. Slow Test Suite**

**Symptoms:** CI taking >20 minutes

**Solutions:**

- Enable test parallelization (Jest `maxWorkers`, Playwright `workers`)
- Use `test.skip` for rarely-failing tests in local development
- Cache dependencies properly
- Optimize `npm ci` with `--prefer-offline`

**3. Lighthouse Failures**

**Symptoms:** Lighthouse scores inconsistent

**Solutions:**

- Run on consistent hardware (GitHub Actions standard runners)
- Disable throttling in CI environment
- Run multiple times and average scores
- Use `lhci autorun` for consistent results

**4. Coverage False Negatives**

**Symptoms:** Coverage reported as low but tests exist

**Solutions:**

- Check `collectCoverageFrom` patterns in `jest.config.js`
- Ensure test files match `testMatch` patterns
- Verify imports are correct (not missing)
- Run with `--verbose` to see coverage calculation

---

## 🔟 Related Documentation

### QuantumPoly-Specific

- [CI/CD Testing Guide](../docs/CICD_TESTING_GUIDE.md) - Manual testing procedures
- [Accessibility Testing](../docs/ACCESSIBILITY_TESTING.md) - Detailed a11y guide
- [API Testing Guide](../docs/API_TESTING_GUIDE.md) - API-specific tests

### Tool Documentation

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Playwright Documentation](https://playwright.dev/docs/intro)
- [Lighthouse Documentation](https://developer.chrome.com/docs/lighthouse)
- [Axe-core Rules](https://github.com/dequelabs/axe-core/blob/develop/doc/rule-descriptions.md)

---

## 📋 Quick Reference

### Test Commands

```bash
# Quality gates (local validation)
npm run lint              # ESLint
npm run typecheck         # TypeScript
npm run test              # Unit tests
npm run test:coverage     # Unit tests with coverage

# Accessibility tests
npm run test:a11y         # jest-axe component tests
npm run test:e2e:a11y     # Playwright axe E2E tests
npm run lh:a11y           # Lighthouse accessibility audit

# Performance tests
npm run budget            # Bundle budget check
npm run lh:perf           # Lighthouse performance audit

# E2E tests
npm run test:e2e          # Full Playwright suite
npm run test:e2e:ui       # Playwright UI mode (debugging)

# CI simulation
npm run ci:quality        # Simulates quality job
```

### Debugging Tests

```bash
# Jest debugging
npm run test:watch        # Watch mode
npm run test -- --verbose # Verbose output

# Playwright debugging
npm run test:e2e:ui       # Interactive UI mode
npx playwright test --debug  # Step-through debugger
npx playwright show-report   # View HTML report

# Coverage visualization
npm run test:coverage     # Generates lcov-report/index.html
open coverage/lcov-report/index.html
```

---

**Prompt Block Version:** v7.2.0  
**Last Updated:** 2025-10-19  
**Maintained By:** CASP Lead Architect  
**Status:** ✅ Production-Ready  
**Dependencies:** Requires Block 7.1 (CI/CD Architecture)
